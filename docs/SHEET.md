# XTF 电子表格算法设计

> 源码位置：[`core/engine.py`](../core/engine.py) · [`api/sheet.py`](../api/sheet.py)

---

## 目录

- [1. 概述](#1-概述)
- [2. 三层大数据稳定上传保障](#2-三层大数据稳定上传保障)
- [3. 智能分块策略](#3-智能分块策略)
- [4. API 接口选择与调用](#4-api-接口选择与调用)
- [5. 公式保护与双读验证](#5-公式保护与双读验证)
- [6. 列级差异检测报告](#6-列级差异检测报告)
- [7. 网格限制处理](#7-网格限制处理)
- [8. 性能基准](#8-性能基准)

---

## 1. 概述

电子表格 (Sheet) 同步与多维表格 (Bitable) 相比，面临独特的技术挑战：

| 挑战 | 原因 | XTF 解决方案 |
|------|------|-------------|
| **请求体积限制** | 单次 API ≤ 10MB | 三层分块 + 二分重试 |
| **行列限制** | 单次 5000 行 × 100 列 | 可配置分块参数 |
| **公式保护** | 覆盖会破坏公式 | 双读检测 + 列级保护 |
| **范围定位** | A1 记法、列号转换 | 自动范围计算与验证 |
| **网格边界** | 格式不能超出数据范围 | 先写数据 → 再设格式 |

---

## 2. 三层大数据稳定上传保障

### 第一层：预分块

在发送 API 请求之前，基于配置参数进行初始分块：

```
DataFrame (N 行 × M 列)
        ↓
按行分块: max(batch_size, sheet_write_max_rows)
        ↓
按列分块: sheet_write_max_cols (默认 100)
        ↓
生成 K 个子块 → 逐块发送
```

**默认分块参数**：

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `sheet_write_max_rows` | `5000` | 写入分块最大行数 |
| `sheet_write_max_cols` | `100` | 写入分块最大列数 |
| `batch_size` | `1000` | 批处理大小 |

### 第二层：自动二分重试

当 API 返回错误码 `90227`（请求体过大）时，自动减半重试：

```
发送 1000 行数据 → 90227 错误
        ↓
行二分：500 行 × 2 次 → 90227 错误（仍然太大）
        ↓
继续行二分：250 行 × 4 次 → 90227 错误
        ↓
列二分：250 行 × 50 列 × 8 次 → 成功 ✓
```

**二分策略**：
1. **行优先**：先尝试减少行数
2. **列兜底**：行数减到最小仍失败时，开始减少列数
3. **最小单元**：单行单列是不可再分的最小单位

### 第三层：智能重试与频控

在前两层基础上，应用通用重试和频率控制机制：

- **默认模式**：固定延迟 + 固定重试次数
- **高级模式**：可配置指数退避/线性增长/滑动窗口等策略

> 详细配置：[CONTROL.md](./CONTROL.md)

---

## 3. 智能分块策略

### 读取分块

```
远程表格 (R 行 × C 列)
        ↓
按区域分块读取：
  ├─ 区域1: A1:CV5000 (列1-100, 行1-5000)
  ├─ 区域2: CW1:FR5000 (列101-200, 行1-5000)
  ├─ 区域3: A5001:CV10000 (列1-100, 行5001-10000)
  └─ ...
        ↓
合并为完整 DataFrame
```

**分块参数**：

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `sheet_scan_max_rows` | `5000` | 每块最大行数 |
| `sheet_scan_max_cols` | `100` | 每块最大列数 |

### 写入分块

写入采用与读取类似的分块策略，但额外包含二分重试机制：

```
待写入数据 → 按(行, 列)预分块 → 逐块写入
                                   ├─ 成功 → 下一块
                                   └─ 90227 → 二分重试
```

### 清空分块

clone 模式下清空数据也需要分块（写入空值）：

```
清空范围 (R 行 × C 列)
        ↓
按 sheet_write_max_rows × sheet_write_max_cols 分块
        ↓
逐块写入空值 (batch_update)
```

---

## 4. API 接口选择与调用

> 源码：`api/sheet.py`

### 接口映射

| 操作 | HTTP 方法 | 端点 | 用途 |
|------|-----------|------|------|
| 获取表信息 | GET | `/sheets/{sheet_id}` | 获取行列数、标题 |
| 读取数据 | GET | `/values/{range}` | 按范围读取单元格 |
| 写入数据 | PUT | `/values` | 精确重写指定范围 |
| 追加数据 | POST | `/values_append` | 智能追加到末尾 |
| 批量更新 | POST | `/values_batch_update` | 多范围同时更新 |
| 设置格式 | PUT | `/styles` | 设置单元格格式 |
| 数据验证 | POST | `/dataValidation` | 创建下拉列表 |

### 各模式的接口调用流程

**Full 模式**：
```
read(索引列) → 匹配 → batch_update(更新行) + append(新行)
```

**Incremental 模式**：
```
read(索引列) → 过滤 → append(新行)
```

**Overwrite 模式**：
```
read(全部) → 过滤保留 → values PUT(重写)
```

**Clone 模式**：
```
get_info(范围) → batch_update(清空) → values PUT(全部写入)
```

---

## 5. 公式保护与双读验证

> 源码：`core/engine.py` → `get_sheet_data_with_validation()`

### 双读策略

当 `sheet_validate_results: true` 或 `sheet_protect_formulas: true` 时，系统执行双读：

```
第一次读取：sheet_value_render_option = "Formula"
    → 获取公式文本，识别哪些列包含公式

第二次读取：sheet_value_render_option = "FormattedValue"
    → 获取计算后的结果值，用于差异对比
```

### 公式列识别

通过 `SheetAPI.identify_formula_columns()` 检测：
- 单元格值以 `=` 开头 → 公式列
- 整列采样判断（非单个单元格）

### 保护逻辑

```
所有列
  ├─ 公式列 → 只检测差异，不覆盖
  └─ 数据列 → 正常同步
```

当 `sheet_protect_formulas: true` 时：
1. 自动启用 `sheet_validate_results: true`
2. 检测公式列
3. 从同步列表中移除公式列
4. 数据列正常同步
5. 公式列仅在报告中显示差异

---

## 6. 列级差异检测报告

> 源码：`core/engine.py` → `validate_and_report_differences()`, `print_column_diff_report()`

### 差异比较逻辑

| 数据类型 | 比较方式 |
|----------|----------|
| 空值 | 双方均为空 → 相等；一方为空 → 不等 |
| 数字 | 差值 ≤ `sheet_diff_tolerance` → 相等 |
| 字符串 | 去除首尾空格后精确比较 |
| 其他 | 转为字符串后比较 |

### 报告结构

```
════════════════════════════════════════════
📊 列差异检测报告
时间: 2024-01-15 10:30:00
模式: 逻辑同步+结果检测
════════════════════════════════════════════
🔒 公式列（已保护，不覆盖）:
  ✓ 销售额: 120/39749 行结果不一致 (0.30%)
  → 建议: 检查输入数据列是否变化

📝 数据列（已同步）:
  ✓ 问题分类: 50 行差异 → 已更新
  ✓ 状态: 10 行差异 → 已更新

⚠️  异常列:
  ✗ 金额: 列数据长度不一致
════════════════════════════════════════════
总计: 3/19 列有差异
同步完成: 2/19 列
保护跳过: 1/19 列
════════════════════════════════════════════
```

### 报告分类

| 分类 | 图标 | 说明 |
|------|------|------|
| 公式列 | 🔒 | 已保护，仅显示差异统计 |
| 数据列 | 📝 | 已同步，显示更新行数 |
| 异常列 | ⚠️ | 比较过程出错 |

---

## 7. 网格限制处理

飞书电子表格的格式化操作不能超出当前网格范围（已有数据的区域）。

### 智能处理顺序

```
1. 先写入数据 → 扩展网格范围
2. 再设置格式 → 在扩展后的范围内操作
```

### 范围验证

每次格式化操作前，系统会自动：
1. 获取当前表格的行列范围
2. 检查目标范围是否在网格内
3. 超出范围的部分自动跳过（优雅降级）
4. 记录详细日志便于调试

---

## 8. 性能基准

不同数据规模下的参考性能（网络状况良好时）：

| 数据规模 | 推荐 batch_size | 推荐分块行数 | 预计耗时 |
|----------|----------------|-------------|----------|
| 1K 行 × 20 列 | 1000 | 5000 | < 10s |
| 5K 行 × 50 列 | 500 | 5000 | 30-60s |
| 10K 行 × 50 列 | 500 | 3000 | 1-3min |
| 50K 行 × 100 列 | 200 | 2000 | 5-15min |

**优化建议**：

| 场景 | 建议 |
|------|------|
| 频繁超时 | 降低 `sheet_write_max_rows`，增大 `max_retries` |
| 90227 错误频繁 | 降低 `batch_size` 和分块参数 |
| 限流 429 | 增大 `rate_limit_delay`，或启用高级频控 |
| 选择性同步 | 使用 `selective_sync` 减少同步列数 |
| 公式保护 | 启用 `sheet_protect_formulas` 避免不必要的覆盖 |
